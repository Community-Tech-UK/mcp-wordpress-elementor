import { z } from 'zod';
import { CommunityTechClient } from '../utils/communitytech-client.js';
import { getBaseUrl, getWpClient, makeWordPressRequest, registerCtInvalidation } from '../wordpress.js';
import { toolSuccess, toolError } from '../types/elementor-types.js';

// Lazy-init client
let ctClient: CommunityTechClient | null = null;
function getClient(): CommunityTechClient {
  if (!ctClient) {
    ctClient = new CommunityTechClient(getBaseUrl(), getWpClient());
  }
  return ctClient;
}

// Invalidate cached client when active site changes
registerCtInvalidation(() => { ctClient = null; });

// Schema definitions
const getKitSettingsSchema = z.object({});

const getGlobalColorsSchema = z.object({});

const updateGlobalColorsSchema = z.object({
  system_colors: z.array(z.any()).optional(),
  custom_colors: z.array(z.any()).optional(),
});

const getGlobalFontsSchema = z.object({});

const updateGlobalFontsSchema = z.object({
  system_typography: z.array(z.any()).optional(),
  custom_typography: z.array(z.any()).optional(),
});

const getThemeStyleSchema = z.object({});

const updateThemeStyleSchema = z.object({
  settings: z.record(z.any()),
});

const getCssVariablesSchema = z.object({});

const clearCacheByPageSchema = z.object({
  post_id: z.coerce.number(),
});

const regenerateCssSchema = z.object({
  post_id: z.coerce.number(),
});

const listWidgetsSchema = z.object({});

// Tool definitions
export const elementorGlobalSettingsTools = [
  {
    name: 'get_elementor_kit_settings',
    description: 'Retrieve the complete Elementor kit settings including global colors, typography, theme styles, and all system settings.',
    inputSchema: {
      type: 'object' as const,
      properties: getKitSettingsSchema.shape,
    },
  },
  {
    name: 'get_elementor_global_colors',
    description: 'Get all global colors defined in Elementor, including both system colors (primary, secondary, text, accent) and custom colors.',
    inputSchema: {
      type: 'object' as const,
      properties: getGlobalColorsSchema.shape,
    },
  },
  {
    name: 'update_elementor_global_colors',
    description: 'Update Elementor global colors. Provide system_colors array to update system colors (primary, secondary, text, accent) and/or custom_colors array for custom color definitions. At least one must be provided.',
    inputSchema: {
      type: 'object' as const,
      properties: updateGlobalColorsSchema.shape,
    },
  },
  {
    name: 'get_elementor_global_fonts',
    description: 'Get all global typography settings from Elementor, including system typography (primary, secondary, text, accent) and custom font definitions.',
    inputSchema: {
      type: 'object' as const,
      properties: getGlobalFontsSchema.shape,
    },
  },
  {
    name: 'update_elementor_global_fonts',
    description: 'Update Elementor global typography settings. Provide system_typography array to update system fonts and/or custom_typography array for custom font definitions. At least one must be provided.',
    inputSchema: {
      type: 'object' as const,
      properties: updateGlobalFontsSchema.shape,
    },
  },
  {
    name: 'get_elementor_theme_style',
    description: 'Retrieve the Elementor theme style settings, which control site-wide styling such as default colors, typography, buttons, and form styles.',
    inputSchema: {
      type: 'object' as const,
      properties: getThemeStyleSchema.shape,
    },
  },
  {
    name: 'update_elementor_theme_style',
    description: 'Update Elementor theme style settings. Provide a settings object with key-value pairs to update specific theme style properties.',
    inputSchema: {
      type: 'object' as const,
      properties: updateThemeStyleSchema.shape,
      required: ['settings'],
    },
  },
  {
    name: 'get_elementor_css_variables',
    description: 'Get all CSS custom properties (variables) generated by Elementor, typically used for global colors and typography.',
    inputSchema: {
      type: 'object' as const,
      properties: getCssVariablesSchema.shape,
    },
  },
  {
    name: 'clear_elementor_cache_by_page',
    description: 'Clear the Elementor CSS cache for a specific page by removing the _elementor_css post meta. Note: This does NOT regenerate the CSS file automatically - the page must be opened in Elementor editor and saved to regenerate CSS.',
    inputSchema: {
      type: 'object' as const,
      properties: clearCacheByPageSchema.shape,
      required: ['post_id'],
    },
  },
  {
    name: 'regenerate_elementor_css',
    description: 'Force regenerate the Elementor CSS file for a specific page/post. Call this after updating Elementor data via update_elementor_data to ensure the page renders correctly with the latest styles.',
    inputSchema: {
      type: 'object' as const,
      properties: regenerateCssSchema.shape,
      required: ['post_id'],
    },
  },
  {
    name: 'list_available_widgets',
    description: 'List all registered Elementor widget types with their categories and descriptions. This includes basic, general, and Pro widgets.',
    inputSchema: {
      type: 'object' as const,
      properties: listWidgetsSchema.shape,
    },
  },
];

// Handler implementations
export const elementorGlobalSettingsHandlers: Record<string, (params: any) => Promise<any>> = {
  get_elementor_kit_settings: async (params) => {
    try {
      const data = await getClient().getKitSettings();
      return toolSuccess(data);
    } catch (error: any) {
      return toolError(`Error fetching kit settings: ${error.message}`);
    }
  },

  get_elementor_global_colors: async (params) => {
    try {
      const data = await getClient().getColors();

      // Format output with summary
      const result = {
        ...data,
        summary: {
          system_colors_count: data.system_colors?.length || 0,
          custom_colors_count: data.custom_colors?.length || 0,
          system_color_names: data.system_colors?.map((c: any) => c._id || c.title).filter(Boolean) || [],
          custom_color_names: data.custom_colors?.map((c: any) => c._id || c.title).filter(Boolean) || [],
        },
      };

      return toolSuccess(result);
    } catch (error: any) {
      return toolError(`Error fetching global colors: ${error.message}`);
    }
  },

  update_elementor_global_colors: async (params) => {
    try {
      const { system_colors, custom_colors } = params;

      if (!system_colors && !custom_colors) {
        throw new Error('At least one of system_colors or custom_colors must be provided');
      }

      const updateData: any = {};
      if (system_colors) {
        updateData.system_colors = system_colors;
      }
      if (custom_colors) {
        updateData.custom_colors = custom_colors;
      }

      const result = await getClient().updateColors(updateData);
      return toolSuccess({
        message: 'Global colors updated successfully',
        updated: {
          system_colors: !!system_colors,
          custom_colors: !!custom_colors,
        },
        result,
      });
    } catch (error: any) {
      return toolError(`Error updating global colors: ${error.message}`);
    }
  },

  get_elementor_global_fonts: async (params) => {
    try {
      const data = await getClient().getFonts();
      return toolSuccess(data);
    } catch (error: any) {
      return toolError(`Error fetching global fonts: ${error.message}`);
    }
  },

  update_elementor_global_fonts: async (params) => {
    try {
      const { system_typography, custom_typography } = params;

      if (!system_typography && !custom_typography) {
        throw new Error('At least one of system_typography or custom_typography must be provided');
      }

      const updateData: any = {};
      if (system_typography) {
        updateData.system_typography = system_typography;
      }
      if (custom_typography) {
        updateData.custom_typography = custom_typography;
      }

      const result = await getClient().updateFonts(updateData);
      return toolSuccess({
        message: 'Global fonts updated successfully',
        updated: {
          system_typography: !!system_typography,
          custom_typography: !!custom_typography,
        },
        result,
      });
    } catch (error: any) {
      return toolError(`Error updating global fonts: ${error.message}`);
    }
  },

  get_elementor_theme_style: async (params) => {
    try {
      const data = await getClient().getThemeStyle();
      return toolSuccess(data);
    } catch (error: any) {
      return toolError(`Error fetching theme style: ${error.message}`);
    }
  },

  update_elementor_theme_style: async (params) => {
    try {
      const { settings } = params;

      if (!settings || typeof settings !== 'object' || Object.keys(settings).length === 0) {
        throw new Error('Settings object must be provided with at least one key-value pair');
      }

      const result = await getClient().updateThemeStyle(settings);
      return toolSuccess({
        message: 'Theme style updated successfully',
        updated_keys: Object.keys(settings),
        result,
      });
    } catch (error: any) {
      return toolError(`Error updating theme style: ${error.message}`);
    }
  },

  get_elementor_css_variables: async (params) => {
    try {
      const data = await getClient().getCssVariables();
      return toolSuccess(data);
    } catch (error: any) {
      return toolError(`Error fetching CSS variables: ${error.message}`);
    }
  },

  clear_elementor_cache_by_page: async (params) => {
    try {
      const { post_id } = params;

      // Try to clear the _elementor_css meta field
      // First try as a post
      try {
        await makeWordPressRequest('POST', `posts/${post_id}`, {
          meta: { _elementor_css: '' },
        });
      } catch (postError: any) {
        // If post fails, try as a page
        try {
          await makeWordPressRequest('POST', `pages/${post_id}`, {
            meta: { _elementor_css: '' },
          });
        } catch (pageError: any) {
          throw new Error(`Failed to clear cache: ${pageError.message}`);
        }
      }

      return toolSuccess({
        message: 'Elementor CSS cache cleared for page',
        post_id,
        note: 'CSS file will not be regenerated until the page is opened in Elementor editor and saved with elementor.saver.defaultSave()',
      });
    } catch (error: any) {
      return toolError(`Error clearing Elementor cache: ${error.message}`);
    }
  },

  regenerate_elementor_css: async (params) => {
    try {
      const { post_id } = params;
      const client = getWpClient();
      const baseUrl = getBaseUrl();
      const response = await client.post(
        `${baseUrl}/wp-json/communitytech/v1/elementor/css/regenerate`,
        { post_id },
        { baseURL: '' }
      );
      return toolSuccess({
        message: 'CSS regenerated successfully',
        post_id,
        ...response.data,
      });
    } catch (error: any) {
      const status = error.response?.status;
      const message = error.response?.data?.message || error.message;

      if (status === 404) {
        return toolError('CommunityTech plugin endpoint not found. Is the plugin installed and activated?');
      }
      return toolError(`Error regenerating CSS: ${message}`);
    }
  },

  list_available_widgets: async (params) => {
    try {
      // Try to get from CommunityTech endpoint first
      try {
        const client = getWpClient();
        const baseUrl = getBaseUrl();
        const response = await client.get(
          `${baseUrl}/wp-json/communitytech/v1/elementor/widgets`,
          { baseURL: '' }
        );
        return toolSuccess(response.data);
      } catch {
        // Fall back to known widget types
        return toolSuccess({
          note: 'CommunityTech plugin endpoint not available. Showing common Elementor widgets.',
          widgets: [
            { type: 'heading', category: 'basic', description: 'Heading text' },
            { type: 'text-editor', category: 'basic', description: 'Rich text editor' },
            { type: 'image', category: 'basic', description: 'Image' },
            { type: 'button', category: 'basic', description: 'Button link' },
            { type: 'divider', category: 'basic', description: 'Horizontal divider' },
            { type: 'spacer', category: 'basic', description: 'Vertical space' },
            { type: 'icon', category: 'basic', description: 'Icon' },
            { type: 'icon-box', category: 'basic', description: 'Icon with text' },
            { type: 'image-box', category: 'basic', description: 'Image with text' },
            { type: 'html', category: 'basic', description: 'Custom HTML' },
            { type: 'video', category: 'basic', description: 'Video embed' },
            { type: 'google_maps', category: 'basic', description: 'Google Maps' },
            { type: 'counter', category: 'general', description: 'Animated counter' },
            { type: 'progress-bar', category: 'general', description: 'Progress bar' },
            { type: 'testimonial', category: 'general', description: 'Testimonial' },
            { type: 'tabs', category: 'general', description: 'Tabbed content' },
            { type: 'accordion', category: 'general', description: 'Accordion' },
            { type: 'toggle', category: 'general', description: 'Toggle content' },
            { type: 'alert', category: 'general', description: 'Alert message' },
            { type: 'social-icons', category: 'general', description: 'Social media icons' },
            { type: 'star-rating', category: 'general', description: 'Star rating' },
            { type: 'icon-list', category: 'general', description: 'Icon list' },
            { type: 'form', category: 'pro', description: 'Form (Elementor Pro)' },
            { type: 'nav-menu', category: 'pro', description: 'Navigation menu (Pro)' },
            { type: 'call-to-action', category: 'pro', description: 'Call to action (Pro)' },
            { type: 'price-table', category: 'pro', description: 'Price table (Pro)' },
            { type: 'price-list', category: 'pro', description: 'Price list (Pro)' },
          ],
        });
      }
    } catch (error: any) {
      return toolError(`Error listing widgets: ${error.message}`);
    }
  },
};
